c
res
c
events.count
events
c
events
c
events
c
events.first
events.all
events
n
events.first
c
exit
  .where(done_by: '')
  .where(to_send: true)
  .where(on_date: given_date_string.to_date).or(where(on_date: given_date_string.to_date+1))
Event
events.first
events
c
events
c
events
c
events
c
events
exit
Event.where(on_date: given_date_string.to_date+1)
Event.where(on_date: given_date_string.to_date)
events = Event.where(on_date: given_date_string.to_date)
events.first
events
c
events.first
events.all
events
c
exit
reminder.reminderable.contract
reminder.reminderable
reminder.reminderable.responsible_user
reminder.reminderable.responsible_useer
reminder.reminderable
reminder.name
reminder.id
n
c
@current_user.allowed_users_ids
exit
@current_user.allowed_users_ids
@current_user
exit
Contract.all.each{|c| print c.id}
Contract.all.to_a {|c| print c.id}
Contract.all{|c| print c.id}
Contract.all
Contract.all{}
Contract.all
Contract.all {|c| print c.id}
Contract.all {|c| c.id}
Contract.all {|c| c.id.to_str}
Contract.all do {|c| c.id.to_str}
Contract.all do {|c| c.id.to_str }
Contract.all do {|c| c.id }
Contract.all do { |c| c.id }
Contract.all
c
@list_type
n
session[:contracts_list_type]
c
session[:contracts_list_type]
c
session[:contracts_list_type]
@list_type
@list_type[:all]
@list_type['all']
@list_type
@list_type[:all]
@list_type
n
@list_type
c
n
session[:contracts_list_type]
n
session[:contracts_list_type]
n
session[:contracts_list_type]
n
'aa' if session[:contracts_list_type]
unless session[:contracts_list_type]
session[:contracts_list_type]
c
session[:contracts_list_type]
c
n
s
n
session[:contracts_list_type]
c
n
session[:contracts_list_type]
c
session[:list_type]
c
is_all_checked
n
s
@list_type[:mine]
@list_type[:all]
@list_type[:all}
@list_type
n
c
table_name
self.table_name
c
n
self.users
n
self.table_name
n
self.table_name
c
self.table_name
n
self.table_name
c
self.table_name
table_name
c
self.table_name
table_name
n
self.table_name
table_name
c
table_name
self.table_name
n
table_name
self.table_name
c
n
s
self.table_name
c
self.table_name
table_name
c
table_name
c
self.table_name
table_name
will_be_joined_across_databases!
self.table_name
table_name
c
self.table_name
table_name
table_name_prefix
table_name
"#{connection.current_database}.#{table_name}"
table_name = "#{connection.current_database}.#{table_name}"
self.table_name_prefix
self.table_prefix
self.table_name
self.will_be_joined_across_databases!
self.table_name
joins(:roles).where('roles_users.deleted_at IS NULL').explain
c
self.roles.pluck(:id)
c
self.roles.pluck(:id)
self.roles
self.roles.pluck(:id)
c
self.roles.pluck(:id)
self.roles.pluck(:id).include?( ::ADMIN_ROLE_ID )
c
res
c
n
c
n
c
==============
===============
=====================
====================
c
all_roles
c
all_roles
c
roles
u
c
u
user
roles
c
params["_json"].respond_to?(:each)
p.respond_to?(:each)
p.respond_to?(~/ch/)
p.respond_to?(/ch/)
p.respond_to?(:each)
p.class
p.methods
p.type
p
c
f
j
s
f
n
exit
"#{dd}.#{mm}.#{yyyy}"
exit
given_date_string.to_date
given_date_string.to_date.to_int
given_date_string.to_date.to_integer
given_date_string.to_date.to_i
given_date_string
given_date_string.to_date
DateTime.new(given_date_string)
Date.new(given_date_string)
Date(given_date_string)
given_date_string
given_date = Date.new(given_date_string)
c
reminder_type_id
given_date
exit
reminders[0].save!
reminders[0].save
reminders.save!
reminders.save
reminders
n
c
n
paths.include?( p[:current] )
args
c
args
paths.include?( p[:current] )
p[:current]
paths
